import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { ethers } from 'ethers';
import { Blockchain } from '../../blockchains/entities/blockchain.entity';
import { Contract } from '../../contracts/entities/contract.entity';
import { Bytecode } from '../../contracts/entities/bytecode.entity';
import {
  ContractType,
  ProviderManager,
} from '../../common/utils/provider.util';
import { UserContractsErrorHelpers } from '../user-contracts.errors';
import { MODULE_NAME, USER_CONTRACT_DEFAULTS } from '../constants';
import { createModuleLogger } from '../../common/utils/logger.util';

@Injectable()
export class UserContractEntityService {
  private readonly logger = createModuleLogger(
    UserContractEntityService,
    MODULE_NAME,
  );

  constructor(
    @InjectRepository(Contract)
    private contractRepository: Repository<Contract>,
    @InjectRepository(Bytecode)
    private bytecodeRepository: Repository<Bytecode>,
    private readonly providerManager: ProviderManager,
  ) {}

  async getOrCreateContract(
    address: string,
    blockchain: Blockchain,
    onChainBytecode: string,
  ): Promise<Contract> {
    this.logger.log(
      `Getting or creating contract entity for address ${address} on blockchain ${blockchain.name}`,
    );

    try {
      const verifiedAddress = ethers.getAddress(address);

      // Check if contract already exists - exact same logic as original
      let contract = await this.contractRepository.findOne({
        where: { blockchain, address: verifiedAddress },
      });

      if (contract) {
        this.logger.debug(
          `Contract entity already exists for address ${verifiedAddress} on blockchain ${blockchain.name}`,
        );
        return contract;
      }

      this.logger.debug(
        `Creating new contract entity for address ${verifiedAddress} on blockchain ${blockchain.name}`,
      );

      // Get or create bytecode first
      const bytecode = await this.getOrCreateBytecode(
        blockchain,
        onChainBytecode,
      );

      // Create new contract with exact same defaults as original
      contract = this.contractRepository.create({
        blockchain,
        address: verifiedAddress,
        bytecode: bytecode,
        lastBid: USER_CONTRACT_DEFAULTS.CONTRACT.LAST_BID,
        bidPlusDecay: USER_CONTRACT_DEFAULTS.CONTRACT.BID_PLUS_DECAY,
        totalBidInvestment:
          USER_CONTRACT_DEFAULTS.CONTRACT.TOTAL_BID_INVESTMENT,
        isAutomated: USER_CONTRACT_DEFAULTS.CONTRACT.IS_AUTOMATED,
        maxBid: USER_CONTRACT_DEFAULTS.CONTRACT.MAX_BID,
      });
      contract = await this.contractRepository.save(contract);

      this.logger.log(
        `Successfully created contract entity ${contract.id} for address ${verifiedAddress} on blockchain ${blockchain.name}`,
      );

      return contract;
    } catch (error) {
      this.logger.error(
        `Failed to create contract entity for ${address}`,
        error,
      );
      UserContractsErrorHelpers.throwContractEntityCreationFailed(
        error instanceof Error ? error.message : 'Unknown error',
      );
      throw new Error('Unreachable');
    }
  }

  async getOrCreateBytecode(
    blockchain: Blockchain,
    onChainBytecode: string,
  ): Promise<Bytecode> {
    this.logger.log(
      `Getting or creating bytecode entity for blockchain ${blockchain.name}`,
    );

    try {
      const bytecodeHash = ethers.keccak256(onChainBytecode);

      this.logger.debug(
        `Generated bytecode hash: ${bytecodeHash} for blockchain ${blockchain.name}`,
      );

      // Check if bytecode already exists - exact same logic as original
      let bytecode = await this.bytecodeRepository.findOne({
        where: {
          blockchain,
          bytecodeHash: bytecodeHash,
        },
      });

      if (bytecode) {
        this.logger.debug(
          `Bytecode entity already exists with hash ${bytecodeHash} for blockchain ${blockchain.name}`,
        );
        return bytecode;
      }

      this.logger.debug(
        `Creating new bytecode entity with hash ${bytecodeHash} for blockchain ${blockchain.name}`,
      );

      // Get contract size using provider manager - exact same logic as original
      const arbWasmContract = this.providerManager.getContract(
        blockchain,
        ContractType.ARB_WASM,
      );
      const contractSizeRaw = (await arbWasmContract.codehashAsmSize(
        bytecodeHash,
      )) as bigint;
      const contractSize = contractSizeRaw.toString();

      this.logger.debug(
        `Retrieved contract size: ${contractSize} for bytecode hash ${bytecodeHash}`,
      );

      // Create new bytecode with exact same defaults as original
      bytecode = this.bytecodeRepository.create({
        blockchain,
        bytecodeHash: bytecodeHash,
        size: contractSize,
        lastBid: USER_CONTRACT_DEFAULTS.BYTECODE.LAST_BID,
        bidPlusDecay: USER_CONTRACT_DEFAULTS.BYTECODE.BID_PLUS_DECAY,
        lastEvictionBid: USER_CONTRACT_DEFAULTS.BYTECODE.LAST_EVICTION_BID,
        isCached: USER_CONTRACT_DEFAULTS.BYTECODE.IS_CACHED,
        totalBidInvestment:
          USER_CONTRACT_DEFAULTS.BYTECODE.TOTAL_BID_INVESTMENT,
      });
      bytecode = await this.bytecodeRepository.save(bytecode);

      this.logger.log(
        `Successfully created bytecode entity ${bytecode.id} with hash ${bytecodeHash} for blockchain ${blockchain.name}`,
      );

      return bytecode;
    } catch (error) {
      this.logger.error(
        `Failed to create bytecode entity for blockchain ${blockchain.id}`,
        error,
      );
      UserContractsErrorHelpers.throwBytecodeCreationFailed(
        error instanceof Error ? error.message : 'Unknown error',
      );
      throw new Error('Unreachable');
    }
  }
}
